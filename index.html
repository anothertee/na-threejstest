<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Nouro Airways Cabin Model</title>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Barlow:wght@100&display=swap" rel="stylesheet">
        <link rel="stylesheet" href="css/main.css">

        <script src="js/three.js"></script>

        <script src="js/OBJLoader.js"></script>
        <script src="js/MTLLoader.js"></script>
        <script src="js/OrbitControls.js"></script>

	</head>
	<body>
        
        <h1>Nouro Airways Cabin</h1>

        <div id="controls">
            <img id="img-1" src="img/pan_lrg.png">
            <img id="img-2" src="img/zoom_lrg.png">
        </div>


        <script>

            const container = document.createElement( 'div' );
            document.body.appendChild( container );

            const renderer = new THREE.WebGLRenderer();
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setClearColor('#141414');
            container.appendChild( renderer.domElement );


            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.1, 10000 )
            camera.position.z = 10;
            camera.position.y = 5;
            camera.position.x = -10;


            const hemiLight = new THREE.HemisphereLight( 0xffffff, 0.2 );
            hemiLight.position.set( 0, 300, 0 );
            scene.add( hemiLight );

            const dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
            dirLight.position.set( 75, 300, -75 );
            scene.add( dirLight );

            var controls;

            controls = new THREE.OrbitControls( camera );
            controls.addEventListener( 'change', 'render' );

            window.addEventListener('resize', onWindowResize, false)
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight
                camera.updateProjectionMatrix()
                renderer.setSize(window.innerWidth, window.innerHeight)
                render()
            }


            // load obj 
            const onProgress = function ( xhr ) {

                if ( xhr.lengthComputable ) {

                    const percentComplete = xhr.loaded / xhr.total * 100;
                    console.log( Math.round( percentComplete, 2 ) + '% downloaded' );

                }

                };

                var mtl_loader = new THREE.MTLLoader();
                    mtl_loader.load('models/final_scene_with-texture-info.mtl',
                        function(materials) {
                            materials.preload()
                                var obj_loader = new THREE.OBJLoader();
                                // obj_loader.setMaterials(materials)
                                obj_loader.load('models/final_scene_with-texture-info.obj',
                                function(object) {
                                    let mesh = object.children[0]
                                    scene.add(mesh);
                                    
                                    object.scale.x = 1;
                                    object.scale.y = 1;
                                    object.scale.z = 1;

                                    scene.add(object)
                                }, null, function(error) {alert(error)}
                            )
                        }, null, function(error) {alert(error)}
                    );


            // math stuff -_-

            this.update = function () {
                // Z
                const alpha = scope.deviceOrientation.alpha 
                    ? THREE.Math.degToRad(scope.deviceOrientation.alpha)
                    : 0;

                // X'
                const beta = scope.deviceOrientation.beta
                    ? THREE.Math.degToRad(scope.deviceOrientation.beta)
                    : 0;

                // Y''
                const gamma = scope.deviceOrientation.gamma 
                    ? THREE.Math.degToRad(scope.deviceOrientation.gamma)
                    : 0;

                // O
                const orient = scope.screenOrientation
                    ? THREE.Math.degToRad(scope.screenOrientation) 
                    : 0;

                const currentQ = new THREE.Quaternion().copy(scope.object.quaternion);

                setObjectQuaternion(currentQ, alpha, beta, gamma, orient);
                const currentAngle = Quat2Angle(currentQ.x, currentQ.y, currentQ.z, currentQ.w);

                // currentAngle.z = left - right
                this.rotateLeft(lastGamma - currentAngle.z);
                lastGamma = currentAngle.z;

                // currentAngle.y = up - down
                this.rotateUp(lastBeta - currentAngle.y);
                lastBeta = currentAngle.y;
                }

                function onDeviceOrientationChangeEvent(event) {
                    scope.deviceOrientation = event;
                    }

                    window.addEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);

                function onScreenOrientationChangeEvent(event) {
                    scope.screenOrientation = window.orientation || 0;
                    }

                    window.addEventListener('orientationchange', onScreenOrientationChangeEvent, false);

                    var setObjectQuaternion = function () {
                        const zee = new THREE.Vector3(0, 0, 1);
                        const euler = new THREE.Euler();
                        const q0 = new THREE.Quaternion();
                        const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0,  Math.sqrt(0.5));

                        return function (quaternion, alpha, beta, gamma, orient) {
                            // 'ZXY' for the device, but 'YXZ' for us
                            euler.set(beta, alpha, -gamma, 'YXZ');

                            // Orient the device
                            quaternion.setFromEuler(euler);

                            // camera looks out the back of the device, not the top
                            quaternion.multiply(q1);

                            // adjust for screen orientation
                            quaternion.multiply(q0.setFromAxisAngle(zee, -orient));
                        }
                        } ();
                    
                        function Quat2Angle(x, y, z, w) {
                    let pitch, roll, yaw;

                    const test = x * y + z * w;
                    // singularity at north pole
                    if (test > 0.499) {
                        yaw = Math.atan2(x, w) * 2;
                        pitch = Math.PI / 2;
                        roll = 0;

                        return new THREE.Vector3(pitch, roll, yaw);
                    }

                    // singularity at south pole
                    if (test < -0.499) {
                        yaw = -2 * Math.atan2(x, w);
                        pitch = -Math.PI / 2;
                        roll = 0;
                        return new THREE.Vector3(pitch, roll, yaw);
                    }

                    const sqx = x * x;
                    const sqy = y * y;
                    const sqz = z * z;

                    yaw = Math.atan2((2 * y * w) - (2 * x * z), 1 - (2 * sqy) - (2 * sqz));
                    pitch = Math.asin(2 * test);
                    roll = Math.atan2((2 * x * w) - (2 * y * z), 1 - (2 * sqx) - (2 * sqz));

                    return new THREE.Vector3(pitch, roll, yaw);
                    }


            // rendering the scene
            function animate() {
                requestAnimationFrame( animate );
                renderer.render( scene, camera );
            }

            animate();
        </script>

    </body>
        
</html>
